//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from RegoParser.g4 by ANTLR 4.13.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace SimpleIdServer.Rego;

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
[System.CLSCompliant(false)]
public partial class RegoParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Comment=1, String=2, Bool=3, Null=4, As=5, Default=6, Else=7, Import=8, 
		Package=9, Not=10, With=11, Set=12, LSBrace=13, LCBrace=14, LParan=15, 
		RSBrace=16, RCBrace=17, RParan=18, Mid=19, FactorOperator=20, ArithOperator=21, 
		RelationOperator=22, EqOper=23, Comma=24, Semicolon=25, Colon=26, Ampersand=27, 
		Dot=28, WhiteSpace=29, LineEnd=30, WindowsLineEnd=31, UnsignedNumber=32, 
		Name=33;
	public const int
		RULE_root = 0, RULE_stmt = 1, RULE_regoPackage = 2, RULE_importDirective = 3, 
		RULE_regoRules = 4, RULE_ruleHead = 5, RULE_ruleBody = 6, RULE_ruleExt = 7, 
		RULE_regoElse = 8, RULE_regoBody = 9, RULE_nonEmptyBraceEnclosedBody = 10, 
		RULE_query = 11, RULE_literal = 12, RULE_literalExpr = 13, RULE_withKeyword = 14, 
		RULE_functionCall = 15, RULE_exprTermPair = 16, RULE_termPair = 17, RULE_exprTermPairList = 18, 
		RULE_exprTerm = 19, RULE_exprTermList = 20, RULE_relationExpr = 21, RULE_bitwiseOrExpr = 22, 
		RULE_bitwiseAndExpr = 23, RULE_arithExpr = 24, RULE_factorExpr = 25, RULE_term = 26, 
		RULE_arrayComprehension = 27, RULE_setComprehension = 28, RULE_objectComprehension = 29, 
		RULE_object_ = 30, RULE_objectItem = 31, RULE_array_ = 32, RULE_set_ = 33, 
		RULE_emptySet = 34, RULE_nonEmptySet = 35, RULE_ref = 36, RULE_refOperand = 37, 
		RULE_refOperandDot = 38, RULE_refOperandCanonical = 39, RULE_scalar = 40;
	public static readonly string[] ruleNames = {
		"root", "stmt", "regoPackage", "importDirective", "regoRules", "ruleHead", 
		"ruleBody", "ruleExt", "regoElse", "regoBody", "nonEmptyBraceEnclosedBody", 
		"query", "literal", "literalExpr", "withKeyword", "functionCall", "exprTermPair", 
		"termPair", "exprTermPairList", "exprTerm", "exprTermList", "relationExpr", 
		"bitwiseOrExpr", "bitwiseAndExpr", "arithExpr", "factorExpr", "term", 
		"arrayComprehension", "setComprehension", "objectComprehension", "object_", 
		"objectItem", "array_", "set_", "emptySet", "nonEmptySet", "ref", "refOperand", 
		"refOperandDot", "refOperandCanonical", "scalar"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, "'null'", "'as'", "'default'", "'else'", "'import'", 
		"'package'", "'not'", "'with'", "'set('", "'['", "'{'", "'('", "']'", 
		"'}'", "')'", "'|'", null, null, null, null, "','", "';'", "':'", "'&'", 
		"'.'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Comment", "String", "Bool", "Null", "As", "Default", "Else", "Import", 
		"Package", "Not", "With", "Set", "LSBrace", "LCBrace", "LParan", "RSBrace", 
		"RCBrace", "RParan", "Mid", "FactorOperator", "ArithOperator", "RelationOperator", 
		"EqOper", "Comma", "Semicolon", "Colon", "Ampersand", "Dot", "WhiteSpace", 
		"LineEnd", "WindowsLineEnd", "UnsignedNumber", "Name"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "RegoParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static RegoParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public RegoParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public RegoParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class RootContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(RegoParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext[] stmt() {
			return GetRuleContexts<StmtContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StmtContext stmt(int i) {
			return GetRuleContext<StmtContext>(i);
		}
		public RootContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_root; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRoot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRoot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoot(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RootContext root() {
		RootContext _localctx = new RootContext(Context, State);
		EnterRule(_localctx, 0, RULE_root);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 85;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 12887062364L) != 0)) {
				{
				{
				State = 82;
				stmt();
				}
				}
				State = 87;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 88;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RegoPackageContext regoPackage() {
			return GetRuleContext<RegoPackageContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImportDirectiveContext importDirective() {
			return GetRuleContext<ImportDirectiveContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RegoRulesContext regoRules() {
			return GetRuleContext<RegoRulesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RegoBodyContext regoBody() {
			return GetRuleContext<RegoBodyContext>(0);
		}
		public StmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StmtContext stmt() {
		StmtContext _localctx = new StmtContext(Context, State);
		EnterRule(_localctx, 2, RULE_stmt);
		try {
			State = 94;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 90;
				regoPackage();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 91;
				importDirective();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 92;
				regoRules();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 93;
				regoBody();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegoPackageContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Package() { return GetToken(RegoParser.Package, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RefContext @ref() {
			return GetRuleContext<RefContext>(0);
		}
		public RegoPackageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regoPackage; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRegoPackage(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRegoPackage(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegoPackage(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RegoPackageContext regoPackage() {
		RegoPackageContext _localctx = new RegoPackageContext(Context, State);
		EnterRule(_localctx, 4, RULE_regoPackage);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 96;
			Match(Package);
			State = 97;
			@ref();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImportDirectiveContext : ParserRuleContext {
		public RefContext import_target;
		public RefContext import_target_rename_as;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Import() { return GetToken(RegoParser.Import, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RefContext[] @ref() {
			return GetRuleContexts<RefContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RefContext @ref(int i) {
			return GetRuleContext<RefContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As() { return GetToken(RegoParser.As, 0); }
		public ImportDirectiveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_importDirective; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterImportDirective(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitImportDirective(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImportDirective(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImportDirectiveContext importDirective() {
		ImportDirectiveContext _localctx = new ImportDirectiveContext(Context, State);
		EnterRule(_localctx, 6, RULE_importDirective);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			Match(Import);
			State = 100;
			_localctx.import_target = @ref();
			State = 103;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==As) {
				{
				State = 101;
				Match(As);
				State = 102;
				_localctx.import_target_rename_as = @ref();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegoRulesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Default() { return GetToken(RegoParser.Default, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Name() { return GetToken(RegoParser.Name, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqOper() { return GetToken(RegoParser.EqOper, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RuleHeadContext ruleHead() {
			return GetRuleContext<RuleHeadContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RuleBodyContext[] ruleBody() {
			return GetRuleContexts<RuleBodyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RuleBodyContext ruleBody(int i) {
			return GetRuleContext<RuleBodyContext>(i);
		}
		public RegoRulesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regoRules; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRegoRules(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRegoRules(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegoRules(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RegoRulesContext regoRules() {
		RegoRulesContext _localctx = new RegoRulesContext(Context, State);
		EnterRule(_localctx, 8, RULE_regoRules);
		try {
			int _alt;
			State = 116;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Default:
				EnterOuterAlt(_localctx, 1);
				{
				State = 105;
				Match(Default);
				State = 106;
				Match(Name);
				State = 107;
				Match(EqOper);
				State = 108;
				term();
				}
				break;
			case Name:
				EnterOuterAlt(_localctx, 2);
				{
				State = 109;
				ruleHead();
				State = 113;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 110;
						ruleBody();
						}
						} 
					}
					State = 115;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleHeadContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Name() { return GetToken(RegoParser.Name, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LParan() { return GetToken(RegoParser.LParan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RParan() { return GetToken(RegoParser.RParan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSBrace() { return GetToken(RegoParser.LSBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext[] exprTerm() {
			return GetRuleContexts<ExprTermContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext exprTerm(int i) {
			return GetRuleContext<ExprTermContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSBrace() { return GetToken(RegoParser.RSBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqOper() { return GetToken(RegoParser.EqOper, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermListContext exprTermList() {
			return GetRuleContext<ExprTermListContext>(0);
		}
		public RuleHeadContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleHead; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRuleHead(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRuleHead(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleHead(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleHeadContext ruleHead() {
		RuleHeadContext _localctx = new RuleHeadContext(Context, State);
		EnterRule(_localctx, 10, RULE_ruleHead);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 118;
			Match(Name);
			State = 124;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
			case 1:
				{
				State = 119;
				Match(LParan);
				State = 121;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 12887061532L) != 0)) {
					{
					State = 120;
					exprTermList();
					}
				}

				State = 123;
				Match(RParan);
				}
				break;
			}
			State = 130;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				{
				State = 126;
				Match(LSBrace);
				State = 127;
				exprTerm();
				State = 128;
				Match(RSBrace);
				}
				break;
			}
			State = 134;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EqOper) {
				{
				State = 132;
				Match(EqOper);
				State = 133;
				exprTerm();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptyBraceEnclosedBodyContext nonEmptyBraceEnclosedBody() {
			return GetRuleContext<NonEmptyBraceEnclosedBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(RegoParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqOper() { return GetToken(RegoParser.EqOper, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext exprTerm() {
			return GetRuleContext<ExprTermContext>(0);
		}
		public RuleBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRuleBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRuleBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleBodyContext ruleBody() {
		RuleBodyContext _localctx = new RuleBodyContext(Context, State);
		EnterRule(_localctx, 12, RULE_ruleBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 141;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Else) {
				{
				State = 136;
				Match(Else);
				State = 139;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EqOper) {
					{
					State = 137;
					Match(EqOper);
					State = 138;
					exprTerm();
					}
				}

				}
			}

			State = 143;
			nonEmptyBraceEnclosedBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RuleExtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RegoElseContext regoElse() {
			return GetRuleContext<RegoElseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptyBraceEnclosedBodyContext nonEmptyBraceEnclosedBody() {
			return GetRuleContext<NonEmptyBraceEnclosedBodyContext>(0);
		}
		public RuleExtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ruleExt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRuleExt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRuleExt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRuleExt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RuleExtContext ruleExt() {
		RuleExtContext _localctx = new RuleExtContext(Context, State);
		EnterRule(_localctx, 14, RULE_ruleExt);
		try {
			State = 147;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Else:
				EnterOuterAlt(_localctx, 1);
				{
				State = 145;
				regoElse();
				}
				break;
			case LCBrace:
				EnterOuterAlt(_localctx, 2);
				{
				State = 146;
				nonEmptyBraceEnclosedBody();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegoElseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(RegoParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqOper() { return GetToken(RegoParser.EqOper, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptyBraceEnclosedBodyContext nonEmptyBraceEnclosedBody() {
			return GetRuleContext<NonEmptyBraceEnclosedBodyContext>(0);
		}
		public RegoElseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regoElse; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRegoElse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRegoElse(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegoElse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RegoElseContext regoElse() {
		RegoElseContext _localctx = new RegoElseContext(Context, State);
		EnterRule(_localctx, 16, RULE_regoElse);
		try {
			State = 156;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 149;
				Match(Else);
				State = 150;
				Match(EqOper);
				State = 151;
				term();
				State = 152;
				nonEmptyBraceEnclosedBody();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 154;
				Match(Else);
				State = 155;
				nonEmptyBraceEnclosedBody();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegoBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public QueryContext query() {
			return GetRuleContext<QueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptyBraceEnclosedBodyContext nonEmptyBraceEnclosedBody() {
			return GetRuleContext<NonEmptyBraceEnclosedBodyContext>(0);
		}
		public RegoBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regoBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRegoBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRegoBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegoBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RegoBodyContext regoBody() {
		RegoBodyContext _localctx = new RegoBodyContext(Context, State);
		EnterRule(_localctx, 18, RULE_regoBody);
		try {
			State = 160;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 158;
				query();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 159;
				nonEmptyBraceEnclosedBody();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NonEmptyBraceEnclosedBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCBrace() { return GetToken(RegoParser.LCBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public QueryContext query() {
			return GetRuleContext<QueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCBrace() { return GetToken(RegoParser.RCBrace, 0); }
		public NonEmptyBraceEnclosedBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nonEmptyBraceEnclosedBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterNonEmptyBraceEnclosedBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitNonEmptyBraceEnclosedBody(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNonEmptyBraceEnclosedBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NonEmptyBraceEnclosedBodyContext nonEmptyBraceEnclosedBody() {
		NonEmptyBraceEnclosedBodyContext _localctx = new NonEmptyBraceEnclosedBodyContext(Context, State);
		EnterRule(_localctx, 20, RULE_nonEmptyBraceEnclosedBody);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 162;
			Match(LCBrace);
			State = 163;
			query();
			State = 164;
			Match(RCBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Semicolon() { return GetTokens(RegoParser.Semicolon); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Semicolon(int i) {
			return GetToken(RegoParser.Semicolon, i);
		}
		public QueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterQuery(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitQuery(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryContext query() {
		QueryContext _localctx = new QueryContext(Context, State);
		EnterRule(_localctx, 22, RULE_query);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 166;
			literal();
			State = 173;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,15,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 168;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==Semicolon) {
						{
						State = 167;
						Match(Semicolon);
						}
					}

					State = 170;
					literal();
					}
					} 
				}
				State = 175;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,15,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralExprContext literalExpr() {
			return GetRuleContext<LiteralExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Not() { return GetToken(RegoParser.Not, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WithKeywordContext[] withKeyword() {
			return GetRuleContexts<WithKeywordContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithKeywordContext withKeyword(int i) {
			return GetRuleContext<WithKeywordContext>(i);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 24, RULE_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 177;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 176;
				Match(Not);
				}
				break;
			}
			State = 179;
			literalExpr();
			State = 183;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==With) {
				{
				{
				State = 180;
				withKeyword();
				}
				}
				State = 185;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext[] exprTerm() {
			return GetRuleContexts<ExprTermContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext exprTerm(int i) {
			return GetRuleContext<ExprTermContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] EqOper() { return GetTokens(RegoParser.EqOper); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EqOper(int i) {
			return GetToken(RegoParser.EqOper, i);
		}
		public LiteralExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterLiteralExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitLiteralExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralExprContext literalExpr() {
		LiteralExprContext _localctx = new LiteralExprContext(Context, State);
		EnterRule(_localctx, 26, RULE_literalExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 186;
			exprTerm();
			State = 191;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==EqOper) {
				{
				{
				State = 187;
				Match(EqOper);
				State = 188;
				exprTerm();
				}
				}
				State = 193;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithKeywordContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode With() { return GetToken(RegoParser.With, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext[] exprTerm() {
			return GetRuleContexts<ExprTermContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext exprTerm(int i) {
			return GetRuleContext<ExprTermContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As() { return GetToken(RegoParser.As, 0); }
		public WithKeywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withKeyword; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterWithKeyword(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitWithKeyword(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithKeyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithKeywordContext withKeyword() {
		WithKeywordContext _localctx = new WithKeywordContext(Context, State);
		EnterRule(_localctx, 28, RULE_withKeyword);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 194;
			Match(With);
			State = 195;
			exprTerm();
			State = 196;
			Match(As);
			State = 197;
			exprTerm();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RefContext @ref() {
			return GetRuleContext<RefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LParan() { return GetToken(RegoParser.LParan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RParan() { return GetToken(RegoParser.RParan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermListContext exprTermList() {
			return GetRuleContext<ExprTermListContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 30, RULE_functionCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 199;
			@ref();
			State = 200;
			Match(LParan);
			State = 202;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 12887061532L) != 0)) {
				{
				State = 201;
				exprTermList();
				}
			}

			State = 204;
			Match(RParan);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprTermPairContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext[] exprTerm() {
			return GetRuleContexts<ExprTermContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext exprTerm(int i) {
			return GetRuleContext<ExprTermContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(RegoParser.Colon, 0); }
		public ExprTermPairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprTermPair; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterExprTermPair(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitExprTermPair(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprTermPair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprTermPairContext exprTermPair() {
		ExprTermPairContext _localctx = new ExprTermPairContext(Context, State);
		EnterRule(_localctx, 32, RULE_exprTermPair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 206;
			exprTerm();
			State = 207;
			Match(Colon);
			State = 208;
			exprTerm();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TermPairContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TermContext[] term() {
			return GetRuleContexts<TermContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term(int i) {
			return GetRuleContext<TermContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(RegoParser.Colon, 0); }
		public TermPairContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_termPair; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterTermPair(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitTermPair(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTermPair(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TermPairContext termPair() {
		TermPairContext _localctx = new TermPairContext(Context, State);
		EnterRule(_localctx, 34, RULE_termPair);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 210;
			term();
			State = 211;
			Match(Colon);
			State = 212;
			term();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprTermPairListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermPairContext[] exprTermPair() {
			return GetRuleContexts<ExprTermPairContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermPairContext exprTermPair(int i) {
			return GetRuleContext<ExprTermPairContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(RegoParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(RegoParser.Comma, i);
		}
		public ExprTermPairListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprTermPairList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterExprTermPairList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitExprTermPairList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprTermPairList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprTermPairListContext exprTermPairList() {
		ExprTermPairListContext _localctx = new ExprTermPairListContext(Context, State);
		EnterRule(_localctx, 36, RULE_exprTermPairList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 214;
			exprTermPair();
			State = 219;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 215;
				Match(Comma);
				State = 216;
				exprTermPair();
				}
				}
				State = 221;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprTermContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RelationExprContext[] relationExpr() {
			return GetRuleContexts<RelationExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationExprContext relationExpr(int i) {
			return GetRuleContext<RelationExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RelationOperator() { return GetTokens(RegoParser.RelationOperator); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RelationOperator(int i) {
			return GetToken(RegoParser.RelationOperator, i);
		}
		public ExprTermContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprTerm; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterExprTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitExprTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprTerm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprTermContext exprTerm() {
		ExprTermContext _localctx = new ExprTermContext(Context, State);
		EnterRule(_localctx, 38, RULE_exprTerm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			relationExpr();
			State = 227;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==RelationOperator) {
				{
				{
				State = 223;
				Match(RelationOperator);
				State = 224;
				relationExpr();
				}
				}
				State = 229;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprTermListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext[] exprTerm() {
			return GetRuleContexts<ExprTermContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext exprTerm(int i) {
			return GetRuleContext<ExprTermContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(RegoParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(RegoParser.Comma, i);
		}
		public ExprTermListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exprTermList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterExprTermList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitExprTermList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExprTermList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprTermListContext exprTermList() {
		ExprTermListContext _localctx = new ExprTermListContext(Context, State);
		EnterRule(_localctx, 40, RULE_exprTermList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 230;
			exprTerm();
			State = 235;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 231;
				Match(Comma);
				State = 232;
				exprTerm();
				}
				}
				State = 237;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BitwiseOrExprContext[] bitwiseOrExpr() {
			return GetRuleContexts<BitwiseOrExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BitwiseOrExprContext bitwiseOrExpr(int i) {
			return GetRuleContext<BitwiseOrExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Mid() { return GetTokens(RegoParser.Mid); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mid(int i) {
			return GetToken(RegoParser.Mid, i);
		}
		public RelationExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRelationExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRelationExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelationExprContext relationExpr() {
		RelationExprContext _localctx = new RelationExprContext(Context, State);
		EnterRule(_localctx, 42, RULE_relationExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 238;
			bitwiseOrExpr();
			State = 243;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Mid) {
				{
				{
				State = 239;
				Match(Mid);
				State = 240;
				bitwiseOrExpr();
				}
				}
				State = 245;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitwiseOrExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public BitwiseAndExprContext[] bitwiseAndExpr() {
			return GetRuleContexts<BitwiseAndExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BitwiseAndExprContext bitwiseAndExpr(int i) {
			return GetRuleContext<BitwiseAndExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Ampersand() { return GetTokens(RegoParser.Ampersand); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand(int i) {
			return GetToken(RegoParser.Ampersand, i);
		}
		public BitwiseOrExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitwiseOrExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterBitwiseOrExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitBitwiseOrExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitwiseOrExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BitwiseOrExprContext bitwiseOrExpr() {
		BitwiseOrExprContext _localctx = new BitwiseOrExprContext(Context, State);
		EnterRule(_localctx, 44, RULE_bitwiseOrExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 246;
			bitwiseAndExpr();
			State = 251;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Ampersand) {
				{
				{
				State = 247;
				Match(Ampersand);
				State = 248;
				bitwiseAndExpr();
				}
				}
				State = 253;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BitwiseAndExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArithExprContext[] arithExpr() {
			return GetRuleContexts<ArithExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArithExprContext arithExpr(int i) {
			return GetRuleContext<ArithExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] ArithOperator() { return GetTokens(RegoParser.ArithOperator); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ArithOperator(int i) {
			return GetToken(RegoParser.ArithOperator, i);
		}
		public BitwiseAndExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitwiseAndExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterBitwiseAndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitBitwiseAndExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitwiseAndExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BitwiseAndExprContext bitwiseAndExpr() {
		BitwiseAndExprContext _localctx = new BitwiseAndExprContext(Context, State);
		EnterRule(_localctx, 46, RULE_bitwiseAndExpr);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 254;
			arithExpr();
			State = 259;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 255;
					Match(ArithOperator);
					State = 256;
					arithExpr();
					}
					} 
				}
				State = 261;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArithExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FactorExprContext[] factorExpr() {
			return GetRuleContexts<FactorExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FactorExprContext factorExpr(int i) {
			return GetRuleContext<FactorExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] FactorOperator() { return GetTokens(RegoParser.FactorOperator); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FactorOperator(int i) {
			return GetToken(RegoParser.FactorOperator, i);
		}
		public ArithExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arithExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterArithExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitArithExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArithExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArithExprContext arithExpr() {
		ArithExprContext _localctx = new ArithExprContext(Context, State);
		EnterRule(_localctx, 48, RULE_arithExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 262;
			factorExpr();
			State = 267;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==FactorOperator) {
				{
				{
				State = 263;
				Match(FactorOperator);
				State = 264;
				factorExpr();
				}
				}
				State = 269;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FactorExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LParan() { return GetToken(RegoParser.LParan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext exprTerm() {
			return GetRuleContext<ExprTermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RParan() { return GetToken(RegoParser.RParan, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		public FactorExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_factorExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterFactorExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitFactorExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFactorExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FactorExprContext factorExpr() {
		FactorExprContext _localctx = new FactorExprContext(Context, State);
		EnterRule(_localctx, 50, RULE_factorExpr);
		try {
			State = 275;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LParan:
				EnterOuterAlt(_localctx, 1);
				{
				State = 270;
				Match(LParan);
				State = 271;
				exprTerm();
				State = 272;
				Match(RParan);
				}
				break;
			case String:
			case Bool:
			case Null:
			case Not:
			case Set:
			case LSBrace:
			case LCBrace:
			case ArithOperator:
			case UnsignedNumber:
			case Name:
				EnterOuterAlt(_localctx, 2);
				{
				State = 274;
				term();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TermContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrayComprehensionContext arrayComprehension() {
			return GetRuleContext<ArrayComprehensionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectComprehensionContext objectComprehension() {
			return GetRuleContext<ObjectComprehensionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetComprehensionContext setComprehension() {
			return GetRuleContext<SetComprehensionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Object_Context object_() {
			return GetRuleContext<Object_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Array_Context array_() {
			return GetRuleContext<Array_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Set_Context set_() {
			return GetRuleContext<Set_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ScalarContext scalar() {
			return GetRuleContext<ScalarContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ArithOperator() { return GetToken(RegoParser.ArithOperator, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RefContext @ref() {
			return GetRuleContext<RefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Not() { return GetToken(RegoParser.Not, 0); }
		public TermContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_term; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitTerm(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TermContext term() {
		TermContext _localctx = new TermContext(Context, State);
		EnterRule(_localctx, 52, RULE_term);
		int _la;
		try {
			State = 292;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 277;
				arrayComprehension();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 278;
				objectComprehension();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 279;
				setComprehension();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 280;
				object_();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 281;
				array_();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 282;
				set_();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 284;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ArithOperator) {
					{
					State = 283;
					Match(ArithOperator);
					}
				}

				State = 286;
				scalar();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 287;
				functionCall();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 289;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Not) {
					{
					State = 288;
					Match(Not);
					}
				}

				State = 291;
				@ref();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayComprehensionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSBrace() { return GetToken(RegoParser.LSBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mid() { return GetToken(RegoParser.Mid, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public QueryContext query() {
			return GetRuleContext<QueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSBrace() { return GetToken(RegoParser.RSBrace, 0); }
		public ArrayComprehensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayComprehension; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterArrayComprehension(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitArrayComprehension(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrayComprehension(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrayComprehensionContext arrayComprehension() {
		ArrayComprehensionContext _localctx = new ArrayComprehensionContext(Context, State);
		EnterRule(_localctx, 54, RULE_arrayComprehension);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 294;
			Match(LSBrace);
			State = 295;
			term();
			State = 296;
			Match(Mid);
			State = 297;
			query();
			State = 298;
			Match(RSBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetComprehensionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCBrace() { return GetToken(RegoParser.LCBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mid() { return GetToken(RegoParser.Mid, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public QueryContext query() {
			return GetRuleContext<QueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCBrace() { return GetToken(RegoParser.RCBrace, 0); }
		public SetComprehensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setComprehension; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterSetComprehension(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitSetComprehension(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetComprehension(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetComprehensionContext setComprehension() {
		SetComprehensionContext _localctx = new SetComprehensionContext(Context, State);
		EnterRule(_localctx, 56, RULE_setComprehension);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 300;
			Match(LCBrace);
			State = 301;
			term();
			State = 302;
			Match(Mid);
			State = 303;
			query();
			State = 304;
			Match(RCBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectComprehensionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCBrace() { return GetToken(RegoParser.LCBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TermPairContext termPair() {
			return GetRuleContext<TermPairContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mid() { return GetToken(RegoParser.Mid, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public QueryContext query() {
			return GetRuleContext<QueryContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCBrace() { return GetToken(RegoParser.RCBrace, 0); }
		public ObjectComprehensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectComprehension; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterObjectComprehension(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitObjectComprehension(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectComprehension(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectComprehensionContext objectComprehension() {
		ObjectComprehensionContext _localctx = new ObjectComprehensionContext(Context, State);
		EnterRule(_localctx, 58, RULE_objectComprehension);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 306;
			Match(LCBrace);
			State = 307;
			termPair();
			State = 308;
			Match(Mid);
			State = 309;
			query();
			State = 310;
			Match(RCBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCBrace() { return GetToken(RegoParser.LCBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCBrace() { return GetToken(RegoParser.RCBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectItemContext[] objectItem() {
			return GetRuleContexts<ObjectItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ObjectItemContext objectItem(int i) {
			return GetRuleContext<ObjectItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(RegoParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(RegoParser.Comma, i);
		}
		public Object_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterObject_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitObject_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_Context object_() {
		Object_Context _localctx = new Object_Context(Context, State);
		EnterRule(_localctx, 60, RULE_object_);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 312;
			Match(LCBrace);
			State = 324;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 12884901916L) != 0)) {
				{
				State = 313;
				objectItem();
				State = 318;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 314;
						Match(Comma);
						State = 315;
						objectItem();
						}
						} 
					}
					State = 320;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
				}
				State = 322;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==Comma) {
					{
					State = 321;
					Match(Comma);
					}
				}

				}
			}

			State = 326;
			Match(RCBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(RegoParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TermContext term() {
			return GetRuleContext<TermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ScalarContext scalar() {
			return GetRuleContext<ScalarContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RefContext @ref() {
			return GetRuleContext<RefContext>(0);
		}
		public ObjectItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterObjectItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitObjectItem(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectItemContext objectItem() {
		ObjectItemContext _localctx = new ObjectItemContext(Context, State);
		EnterRule(_localctx, 62, RULE_objectItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 330;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case String:
			case Bool:
			case Null:
			case UnsignedNumber:
				{
				State = 328;
				scalar();
				}
				break;
			case Name:
				{
				State = 329;
				@ref();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 332;
			Match(Colon);
			State = 333;
			term();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Array_Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSBrace() { return GetToken(RegoParser.LSBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSBrace() { return GetToken(RegoParser.RSBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermListContext exprTermList() {
			return GetRuleContext<ExprTermListContext>(0);
		}
		public Array_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_array_; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterArray_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitArray_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray_(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Array_Context array_() {
		Array_Context _localctx = new Array_Context(Context, State);
		EnterRule(_localctx, 64, RULE_array_);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 335;
			Match(LSBrace);
			State = 337;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 12887061532L) != 0)) {
				{
				State = 336;
				exprTermList();
				}
			}

			State = 339;
			Match(RSBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EmptySetContext emptySet() {
			return GetRuleContext<EmptySetContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptySetContext nonEmptySet() {
			return GetRuleContext<NonEmptySetContext>(0);
		}
		public Set_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterSet_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitSet_(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_Context set_() {
		Set_Context _localctx = new Set_Context(Context, State);
		EnterRule(_localctx, 66, RULE_set_);
		try {
			State = 343;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Set:
				EnterOuterAlt(_localctx, 1);
				{
				State = 341;
				emptySet();
				}
				break;
			case LCBrace:
				EnterOuterAlt(_localctx, 2);
				{
				State = 342;
				nonEmptySet();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EmptySetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Set() { return GetToken(RegoParser.Set, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RParan() { return GetToken(RegoParser.RParan, 0); }
		public EmptySetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_emptySet; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterEmptySet(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitEmptySet(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEmptySet(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EmptySetContext emptySet() {
		EmptySetContext _localctx = new EmptySetContext(Context, State);
		EnterRule(_localctx, 68, RULE_emptySet);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 345;
			Match(Set);
			State = 346;
			Match(RParan);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NonEmptySetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCBrace() { return GetToken(RegoParser.LCBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermListContext exprTermList() {
			return GetRuleContext<ExprTermListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCBrace() { return GetToken(RegoParser.RCBrace, 0); }
		public NonEmptySetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nonEmptySet; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterNonEmptySet(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitNonEmptySet(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNonEmptySet(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NonEmptySetContext nonEmptySet() {
		NonEmptySetContext _localctx = new NonEmptySetContext(Context, State);
		EnterRule(_localctx, 70, RULE_nonEmptySet);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 348;
			Match(LCBrace);
			State = 349;
			exprTermList();
			State = 350;
			Match(RCBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Name() { return GetToken(RegoParser.Name, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RefOperandContext[] refOperand() {
			return GetRuleContexts<RefOperandContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RefOperandContext refOperand(int i) {
			return GetRuleContext<RefOperandContext>(i);
		}
		public RefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ref; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefContext @ref() {
		RefContext _localctx = new RefContext(Context, State);
		EnterRule(_localctx, 72, RULE_ref);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 352;
			Match(Name);
			State = 356;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 353;
					refOperand();
					}
					} 
				}
				State = 358;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefOperandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RefOperandDotContext refOperandDot() {
			return GetRuleContext<RefOperandDotContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RefOperandCanonicalContext refOperandCanonical() {
			return GetRuleContext<RefOperandCanonicalContext>(0);
		}
		public RefOperandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refOperand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRefOperand(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRefOperand(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefOperand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefOperandContext refOperand() {
		RefOperandContext _localctx = new RefOperandContext(Context, State);
		EnterRule(_localctx, 74, RULE_refOperand);
		try {
			State = 361;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Dot:
				EnterOuterAlt(_localctx, 1);
				{
				State = 359;
				refOperandDot();
				}
				break;
			case LSBrace:
				EnterOuterAlt(_localctx, 2);
				{
				State = 360;
				refOperandCanonical();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefOperandDotContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(RegoParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Name() { return GetToken(RegoParser.Name, 0); }
		public RefOperandDotContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refOperandDot; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRefOperandDot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRefOperandDot(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefOperandDot(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefOperandDotContext refOperandDot() {
		RefOperandDotContext _localctx = new RefOperandDotContext(Context, State);
		EnterRule(_localctx, 76, RULE_refOperandDot);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 363;
			Match(Dot);
			State = 364;
			Match(Name);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefOperandCanonicalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LSBrace() { return GetToken(RegoParser.LSBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprTermContext exprTerm() {
			return GetRuleContext<ExprTermContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RSBrace() { return GetToken(RegoParser.RSBrace, 0); }
		public RefOperandCanonicalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refOperandCanonical; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterRefOperandCanonical(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitRefOperandCanonical(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefOperandCanonical(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefOperandCanonicalContext refOperandCanonical() {
		RefOperandCanonicalContext _localctx = new RefOperandCanonicalContext(Context, State);
		EnterRule(_localctx, 78, RULE_refOperandCanonical);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 366;
			Match(LSBrace);
			State = 367;
			exprTerm();
			State = 368;
			Match(RSBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScalarContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UnsignedNumber() { return GetToken(RegoParser.UnsignedNumber, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(RegoParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Bool() { return GetToken(RegoParser.Bool, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Null() { return GetToken(RegoParser.Null, 0); }
		public ScalarContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scalar; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.EnterScalar(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRegoParserListener typedListener = listener as IRegoParserListener;
			if (typedListener != null) typedListener.ExitScalar(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRegoParserVisitor<TResult> typedVisitor = visitor as IRegoParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScalar(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScalarContext scalar() {
		ScalarContext _localctx = new ScalarContext(Context, State);
		EnterRule(_localctx, 80, RULE_scalar);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 370;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 4294967324L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,33,373,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,1,0,5,0,84,8,0,10,0,
		12,0,87,9,0,1,0,1,0,1,1,1,1,1,1,1,1,3,1,95,8,1,1,2,1,2,1,2,1,3,1,3,1,3,
		1,3,3,3,104,8,3,1,4,1,4,1,4,1,4,1,4,1,4,5,4,112,8,4,10,4,12,4,115,9,4,
		3,4,117,8,4,1,5,1,5,1,5,3,5,122,8,5,1,5,3,5,125,8,5,1,5,1,5,1,5,1,5,3,
		5,131,8,5,1,5,1,5,3,5,135,8,5,1,6,1,6,1,6,3,6,140,8,6,3,6,142,8,6,1,6,
		1,6,1,7,1,7,3,7,148,8,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,157,8,8,1,9,1,
		9,3,9,161,8,9,1,10,1,10,1,10,1,10,1,11,1,11,3,11,169,8,11,1,11,5,11,172,
		8,11,10,11,12,11,175,9,11,1,12,3,12,178,8,12,1,12,1,12,5,12,182,8,12,10,
		12,12,12,185,9,12,1,13,1,13,1,13,5,13,190,8,13,10,13,12,13,193,9,13,1,
		14,1,14,1,14,1,14,1,14,1,15,1,15,1,15,3,15,203,8,15,1,15,1,15,1,16,1,16,
		1,16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,18,5,18,218,8,18,10,18,12,18,
		221,9,18,1,19,1,19,1,19,5,19,226,8,19,10,19,12,19,229,9,19,1,20,1,20,1,
		20,5,20,234,8,20,10,20,12,20,237,9,20,1,21,1,21,1,21,5,21,242,8,21,10,
		21,12,21,245,9,21,1,22,1,22,1,22,5,22,250,8,22,10,22,12,22,253,9,22,1,
		23,1,23,1,23,5,23,258,8,23,10,23,12,23,261,9,23,1,24,1,24,1,24,5,24,266,
		8,24,10,24,12,24,269,9,24,1,25,1,25,1,25,1,25,1,25,3,25,276,8,25,1,26,
		1,26,1,26,1,26,1,26,1,26,1,26,3,26,285,8,26,1,26,1,26,1,26,3,26,290,8,
		26,1,26,3,26,293,8,26,1,27,1,27,1,27,1,27,1,27,1,27,1,28,1,28,1,28,1,28,
		1,28,1,28,1,29,1,29,1,29,1,29,1,29,1,29,1,30,1,30,1,30,1,30,5,30,317,8,
		30,10,30,12,30,320,9,30,1,30,3,30,323,8,30,3,30,325,8,30,1,30,1,30,1,31,
		1,31,3,31,331,8,31,1,31,1,31,1,31,1,32,1,32,3,32,338,8,32,1,32,1,32,1,
		33,1,33,3,33,344,8,33,1,34,1,34,1,34,1,35,1,35,1,35,1,35,1,36,1,36,5,36,
		355,8,36,10,36,12,36,358,9,36,1,37,1,37,3,37,362,8,37,1,38,1,38,1,38,1,
		39,1,39,1,39,1,39,1,40,1,40,1,40,0,0,41,0,2,4,6,8,10,12,14,16,18,20,22,
		24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,
		72,74,76,78,80,0,1,2,0,2,4,32,32,379,0,85,1,0,0,0,2,94,1,0,0,0,4,96,1,
		0,0,0,6,99,1,0,0,0,8,116,1,0,0,0,10,118,1,0,0,0,12,141,1,0,0,0,14,147,
		1,0,0,0,16,156,1,0,0,0,18,160,1,0,0,0,20,162,1,0,0,0,22,166,1,0,0,0,24,
		177,1,0,0,0,26,186,1,0,0,0,28,194,1,0,0,0,30,199,1,0,0,0,32,206,1,0,0,
		0,34,210,1,0,0,0,36,214,1,0,0,0,38,222,1,0,0,0,40,230,1,0,0,0,42,238,1,
		0,0,0,44,246,1,0,0,0,46,254,1,0,0,0,48,262,1,0,0,0,50,275,1,0,0,0,52,292,
		1,0,0,0,54,294,1,0,0,0,56,300,1,0,0,0,58,306,1,0,0,0,60,312,1,0,0,0,62,
		330,1,0,0,0,64,335,1,0,0,0,66,343,1,0,0,0,68,345,1,0,0,0,70,348,1,0,0,
		0,72,352,1,0,0,0,74,361,1,0,0,0,76,363,1,0,0,0,78,366,1,0,0,0,80,370,1,
		0,0,0,82,84,3,2,1,0,83,82,1,0,0,0,84,87,1,0,0,0,85,83,1,0,0,0,85,86,1,
		0,0,0,86,88,1,0,0,0,87,85,1,0,0,0,88,89,5,0,0,1,89,1,1,0,0,0,90,95,3,4,
		2,0,91,95,3,6,3,0,92,95,3,8,4,0,93,95,3,18,9,0,94,90,1,0,0,0,94,91,1,0,
		0,0,94,92,1,0,0,0,94,93,1,0,0,0,95,3,1,0,0,0,96,97,5,9,0,0,97,98,3,72,
		36,0,98,5,1,0,0,0,99,100,5,8,0,0,100,103,3,72,36,0,101,102,5,5,0,0,102,
		104,3,72,36,0,103,101,1,0,0,0,103,104,1,0,0,0,104,7,1,0,0,0,105,106,5,
		6,0,0,106,107,5,33,0,0,107,108,5,23,0,0,108,117,3,52,26,0,109,113,3,10,
		5,0,110,112,3,12,6,0,111,110,1,0,0,0,112,115,1,0,0,0,113,111,1,0,0,0,113,
		114,1,0,0,0,114,117,1,0,0,0,115,113,1,0,0,0,116,105,1,0,0,0,116,109,1,
		0,0,0,117,9,1,0,0,0,118,124,5,33,0,0,119,121,5,15,0,0,120,122,3,40,20,
		0,121,120,1,0,0,0,121,122,1,0,0,0,122,123,1,0,0,0,123,125,5,18,0,0,124,
		119,1,0,0,0,124,125,1,0,0,0,125,130,1,0,0,0,126,127,5,13,0,0,127,128,3,
		38,19,0,128,129,5,16,0,0,129,131,1,0,0,0,130,126,1,0,0,0,130,131,1,0,0,
		0,131,134,1,0,0,0,132,133,5,23,0,0,133,135,3,38,19,0,134,132,1,0,0,0,134,
		135,1,0,0,0,135,11,1,0,0,0,136,139,5,7,0,0,137,138,5,23,0,0,138,140,3,
		38,19,0,139,137,1,0,0,0,139,140,1,0,0,0,140,142,1,0,0,0,141,136,1,0,0,
		0,141,142,1,0,0,0,142,143,1,0,0,0,143,144,3,20,10,0,144,13,1,0,0,0,145,
		148,3,16,8,0,146,148,3,20,10,0,147,145,1,0,0,0,147,146,1,0,0,0,148,15,
		1,0,0,0,149,150,5,7,0,0,150,151,5,23,0,0,151,152,3,52,26,0,152,153,3,20,
		10,0,153,157,1,0,0,0,154,155,5,7,0,0,155,157,3,20,10,0,156,149,1,0,0,0,
		156,154,1,0,0,0,157,17,1,0,0,0,158,161,3,22,11,0,159,161,3,20,10,0,160,
		158,1,0,0,0,160,159,1,0,0,0,161,19,1,0,0,0,162,163,5,14,0,0,163,164,3,
		22,11,0,164,165,5,17,0,0,165,21,1,0,0,0,166,173,3,24,12,0,167,169,5,25,
		0,0,168,167,1,0,0,0,168,169,1,0,0,0,169,170,1,0,0,0,170,172,3,24,12,0,
		171,168,1,0,0,0,172,175,1,0,0,0,173,171,1,0,0,0,173,174,1,0,0,0,174,23,
		1,0,0,0,175,173,1,0,0,0,176,178,5,10,0,0,177,176,1,0,0,0,177,178,1,0,0,
		0,178,179,1,0,0,0,179,183,3,26,13,0,180,182,3,28,14,0,181,180,1,0,0,0,
		182,185,1,0,0,0,183,181,1,0,0,0,183,184,1,0,0,0,184,25,1,0,0,0,185,183,
		1,0,0,0,186,191,3,38,19,0,187,188,5,23,0,0,188,190,3,38,19,0,189,187,1,
		0,0,0,190,193,1,0,0,0,191,189,1,0,0,0,191,192,1,0,0,0,192,27,1,0,0,0,193,
		191,1,0,0,0,194,195,5,11,0,0,195,196,3,38,19,0,196,197,5,5,0,0,197,198,
		3,38,19,0,198,29,1,0,0,0,199,200,3,72,36,0,200,202,5,15,0,0,201,203,3,
		40,20,0,202,201,1,0,0,0,202,203,1,0,0,0,203,204,1,0,0,0,204,205,5,18,0,
		0,205,31,1,0,0,0,206,207,3,38,19,0,207,208,5,26,0,0,208,209,3,38,19,0,
		209,33,1,0,0,0,210,211,3,52,26,0,211,212,5,26,0,0,212,213,3,52,26,0,213,
		35,1,0,0,0,214,219,3,32,16,0,215,216,5,24,0,0,216,218,3,32,16,0,217,215,
		1,0,0,0,218,221,1,0,0,0,219,217,1,0,0,0,219,220,1,0,0,0,220,37,1,0,0,0,
		221,219,1,0,0,0,222,227,3,42,21,0,223,224,5,22,0,0,224,226,3,42,21,0,225,
		223,1,0,0,0,226,229,1,0,0,0,227,225,1,0,0,0,227,228,1,0,0,0,228,39,1,0,
		0,0,229,227,1,0,0,0,230,235,3,38,19,0,231,232,5,24,0,0,232,234,3,38,19,
		0,233,231,1,0,0,0,234,237,1,0,0,0,235,233,1,0,0,0,235,236,1,0,0,0,236,
		41,1,0,0,0,237,235,1,0,0,0,238,243,3,44,22,0,239,240,5,19,0,0,240,242,
		3,44,22,0,241,239,1,0,0,0,242,245,1,0,0,0,243,241,1,0,0,0,243,244,1,0,
		0,0,244,43,1,0,0,0,245,243,1,0,0,0,246,251,3,46,23,0,247,248,5,27,0,0,
		248,250,3,46,23,0,249,247,1,0,0,0,250,253,1,0,0,0,251,249,1,0,0,0,251,
		252,1,0,0,0,252,45,1,0,0,0,253,251,1,0,0,0,254,259,3,48,24,0,255,256,5,
		21,0,0,256,258,3,48,24,0,257,255,1,0,0,0,258,261,1,0,0,0,259,257,1,0,0,
		0,259,260,1,0,0,0,260,47,1,0,0,0,261,259,1,0,0,0,262,267,3,50,25,0,263,
		264,5,20,0,0,264,266,3,50,25,0,265,263,1,0,0,0,266,269,1,0,0,0,267,265,
		1,0,0,0,267,268,1,0,0,0,268,49,1,0,0,0,269,267,1,0,0,0,270,271,5,15,0,
		0,271,272,3,38,19,0,272,273,5,18,0,0,273,276,1,0,0,0,274,276,3,52,26,0,
		275,270,1,0,0,0,275,274,1,0,0,0,276,51,1,0,0,0,277,293,3,54,27,0,278,293,
		3,58,29,0,279,293,3,56,28,0,280,293,3,60,30,0,281,293,3,64,32,0,282,293,
		3,66,33,0,283,285,5,21,0,0,284,283,1,0,0,0,284,285,1,0,0,0,285,286,1,0,
		0,0,286,293,3,80,40,0,287,293,3,30,15,0,288,290,5,10,0,0,289,288,1,0,0,
		0,289,290,1,0,0,0,290,291,1,0,0,0,291,293,3,72,36,0,292,277,1,0,0,0,292,
		278,1,0,0,0,292,279,1,0,0,0,292,280,1,0,0,0,292,281,1,0,0,0,292,282,1,
		0,0,0,292,284,1,0,0,0,292,287,1,0,0,0,292,289,1,0,0,0,293,53,1,0,0,0,294,
		295,5,13,0,0,295,296,3,52,26,0,296,297,5,19,0,0,297,298,3,22,11,0,298,
		299,5,16,0,0,299,55,1,0,0,0,300,301,5,14,0,0,301,302,3,52,26,0,302,303,
		5,19,0,0,303,304,3,22,11,0,304,305,5,17,0,0,305,57,1,0,0,0,306,307,5,14,
		0,0,307,308,3,34,17,0,308,309,5,19,0,0,309,310,3,22,11,0,310,311,5,17,
		0,0,311,59,1,0,0,0,312,324,5,14,0,0,313,318,3,62,31,0,314,315,5,24,0,0,
		315,317,3,62,31,0,316,314,1,0,0,0,317,320,1,0,0,0,318,316,1,0,0,0,318,
		319,1,0,0,0,319,322,1,0,0,0,320,318,1,0,0,0,321,323,5,24,0,0,322,321,1,
		0,0,0,322,323,1,0,0,0,323,325,1,0,0,0,324,313,1,0,0,0,324,325,1,0,0,0,
		325,326,1,0,0,0,326,327,5,17,0,0,327,61,1,0,0,0,328,331,3,80,40,0,329,
		331,3,72,36,0,330,328,1,0,0,0,330,329,1,0,0,0,331,332,1,0,0,0,332,333,
		5,26,0,0,333,334,3,52,26,0,334,63,1,0,0,0,335,337,5,13,0,0,336,338,3,40,
		20,0,337,336,1,0,0,0,337,338,1,0,0,0,338,339,1,0,0,0,339,340,5,16,0,0,
		340,65,1,0,0,0,341,344,3,68,34,0,342,344,3,70,35,0,343,341,1,0,0,0,343,
		342,1,0,0,0,344,67,1,0,0,0,345,346,5,12,0,0,346,347,5,18,0,0,347,69,1,
		0,0,0,348,349,5,14,0,0,349,350,3,40,20,0,350,351,5,17,0,0,351,71,1,0,0,
		0,352,356,5,33,0,0,353,355,3,74,37,0,354,353,1,0,0,0,355,358,1,0,0,0,356,
		354,1,0,0,0,356,357,1,0,0,0,357,73,1,0,0,0,358,356,1,0,0,0,359,362,3,76,
		38,0,360,362,3,78,39,0,361,359,1,0,0,0,361,360,1,0,0,0,362,75,1,0,0,0,
		363,364,5,28,0,0,364,365,5,33,0,0,365,77,1,0,0,0,366,367,5,13,0,0,367,
		368,3,38,19,0,368,369,5,16,0,0,369,79,1,0,0,0,370,371,7,0,0,0,371,81,1,
		0,0,0,39,85,94,103,113,116,121,124,130,134,139,141,147,156,160,168,173,
		177,183,191,202,219,227,235,243,251,259,267,275,284,289,292,318,322,324,
		330,337,343,356,361
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
